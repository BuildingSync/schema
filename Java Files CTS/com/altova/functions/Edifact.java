/**
 * Edifact.java
 *
 * This file was generated by MapForce 2016r2.
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the MapForce Documentation for further details.
 * http://www.altova.com/mapforce
 */
package com.altova.functions;

import com.altova.CoreTypes;
import com.altova.types.DateTime;
import com.altova.types.Duration;

public class Edifact 
{

  // ---------- date / time functions ----------

  /* The result is the date / time / datetime value extracted from the coded source using the given format code.
   */
  public static String autoformat( String sValue, String sFormat ) {

	String result = null;

	int i = 0;
	char[] arrValue = sValue.toCharArray();

	switch( Integer.parseInt(sFormat) )
	{
		// DDD
		// Day's number within a specific year: D = Day.
		case 107:
		{
			checkMinMaxLength ( sValue, sFormat, 1, 3 );
			// Note: gDay cannot accommodate all values. So we return a days-duration.
			int days = Integer.parseInt( sValue );
			Duration dur = new Duration( 0, 0, days, 0, 0, 0, 0.0, false );
			result = dur.toString();
		}
			break;

		// WW
		// Week's number within a specific year: W = Week.
		case 108:
		{
			checkMinMaxLength ( sValue, sFormat, 1, 2 );
			// Note: A 'gWeek' does not exist and gDay cannot accommodate all values. So we return a days-duration.
			int weeksNum = Integer.parseInt( sValue );
			Duration dur = new Duration( 0, 0, weeksNum * 7, 0, 0, 0, 0.0, false );
			result = dur.toString();
		}
			break;

		// MM
		// Month's number within a specific year: M = Month.
		case 109:
		{
			checkMinMaxLength ( sValue, sFormat, 1, 2 );
			// gMonth
			int month = Integer.parseInt( sValue );
			Duration dur = new Duration( 0, month, 0, 0, 0, 0, 0.0, false );
			result = dur.toString();
		}
			break;

		// DD
		// Day's number within is a specific month: D = Day.
		case 110:
		{
			checkMinMaxLength ( sValue, sFormat, 1, 2 );
			// gDay
			int days = Integer.parseInt( sValue );
			Duration dur = new Duration( 0, 0, days, 0, 0, 0, 0.0, false );
			result = dur.toString();
		}
			break;

		// CC
		// Century.
		case 600:
		{
			checkMinMaxLength ( sValue, sFormat, 1, 2 );
			int century = Integer.parseInt( sValue );
			result = CoreTypes.formatNumber(Y2KConvert.Year( century, 0 ), 4);
		}
			break;

		// YY
		// Calendar year: Y = Year.
		case 601:
		{
			checkMinMaxLength ( sValue, sFormat, 1, 2 );
			// gYear
			int number = Y2KConvert.Year( Integer.parseInt( sValue ) );
			result = CoreTypes.formatNumber(number, 4);
		}
			break;

		// CCYY
		// Calendar year including century: C = Century; Y = Year.
		case 602:
		{
			checkLength ( sValue, sFormat, 4 );
	
			int cc = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int yy = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int number = Y2KConvert.Year( cc, yy );
			result = CoreTypes.formatNumber(number, 4);
		}
			break;

		// YYS
		// Semester in a calendar year: Y = Year; S = Semester.
		case 603:
		{
			checkLength ( sValue, sFormat, 3 );

			int yy = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int semester  = Integer.parseInt( new String( arrValue, i, 1 ) );  i += 1;
			result = CoreTypes.formatNumber(Y2KConvert.Year( yy ), 4) + "-" + CoreTypes.formatNumber((semester - 1) * 6 + 1, 2);
		}
			break;

		// CCYYS
		// Semester in a calendar year: C = Century; Y = Year; S = Semester.
		case 604:
		{
			checkLength ( sValue, sFormat, 5 );
			// gYearMonth
			int cc = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int yy = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int semester  = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			result = CoreTypes.formatNumber(Y2KConvert.Year( cc, yy ), 4) + "-" + CoreTypes.formatNumber((semester - 1) * 6 + 1, 2);
		}
			break;

		// CCYYQ
		// Quarter in a calendar year: C = Century; Y = Year; Q = Quarter.
		case 608:
		{
			checkLength ( sValue, sFormat, 5 );
			// gYearMonth
			int cc = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int yy = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int quarter  = Integer.parseInt( new String( arrValue, i, 1 ) );  i += 1;
			if ( quarter != 1)
				quarter = ( ( quarter - 1 ) * 3  + 1);
			result = CoreTypes.formatNumber(Y2KConvert.Year( cc, yy ), 4) + "-" + CoreTypes.formatNumber(quarter, 2);
		}
			break;

		// YYMM
		// Month within a calendar year: Y = Year; M = Month.
		case 609:
		{
			checkLength ( sValue, sFormat, 4 );
			// gYearMonth
			int yy = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int mm = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			result = CoreTypes.formatNumber(Y2KConvert.Year( yy ), 4) + "-" + CoreTypes.formatNumber(mm, 2);
		}
			break;

		// CCYYMM
		// Month within a calendar year: CC = Century; Y = Year; M = Month.
		case 610:
		{
			checkLength ( sValue, sFormat, 6 );
			// gYearMonth
			int cc = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int yy = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int mm = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			result = CoreTypes.formatNumber(Y2KConvert.Year( cc, yy ), 4) + "-" + CoreTypes.formatNumber(mm, 2);
		}
			break;

		// YYMMA
		// To specifiy a ten-day period within a month of a year (A = ten day period).
		case 613:
		{
			checkLength ( sValue, sFormat, 5 );
			int yy = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int mm = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int period  = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;

			DateTime date = new DateTime( Y2KConvert.Year( yy ), mm, 10 * (period - 1) + 1 );
			result = date.toDateString();
		}
			break;

		// CCYYMMA
		// To specifiy a ten-day period within a month of a year, including century  (A = ten day period).
		case 614:
		{
			checkLength ( sValue, sFormat, 7 );
			int cc = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int yy = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int mm = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int period  = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;

			DateTime date = new DateTime( Y2KConvert.Year( cc, yy ), mm, 10 * (period - 1) + 1 );
			result = date.toDateString();
		}
			break;

		// Day of the week
		// Numeric representation of the day (Monday = 1).
		case 813:
		{
			int dayofweek = Integer.parseInt( sValue );
			dayofweek = (dayofweek + 6) % 7;	// make Monday = 0
			Duration dur = Duration.getFromDayTime( dayofweek, 0, 0, 0, 0.0 );
			result = dur.toString();
		}
			break;

		// Working days
		// Number of working days.
		case 814:
		{
			int number = Integer.parseInt( sValue );
			number = (number / 5) * 7 + number % 5;
			Duration dur = Duration.getFromDayTime( number, 0, 0, 0, 0.0 );
			result = dur.toString();
		}
			break;

		default:
		{
		
			DateTime time = Edifact.toTime( sValue, sFormat, false );
			if( time != null ) return time.toTimeString();

			DateTime date = Edifact.toDate( sValue, sFormat, false );
			if( date != null ) return date.toDateString(true);

			Duration duration = Edifact.toDuration( sValue, sFormat, false );
			if( duration != null ) return duration.toString();

			DateTime datetime = Edifact.toDatetime( sValue, sFormat, false );
			if( datetime != null ) return datetime.toString();

			result = sValue;
			
		}
			break;
	}

	return result;
  }

  /* The result is the time value extracted from the coded source using the given format code.
   */
  public static DateTime toTime( String sValue, String sFormat )
  {
	  return Edifact.toTime( sValue, sFormat, true );
  }

  
   // Overloaded method with control parameter for the default-switch exception
   
  private static DateTime toTime( String sValue, String sFormat, boolean bRaiseExc )
  {

	DateTime result = null;

	int hour = 0;
	int minute = 0;
	int seconds = 0;
	int i = 0;

	char[] arrValue = sValue.toCharArray();

	switch( Integer.parseInt(sFormat) )
	{
		// HHMM
		// Time without seconds: H = Hour; m = Minute.
		case 401:
		{
			checkLength ( sValue, sFormat, 4 );
			hour	 = Integer.parseInt( new String( arrValue, i, 2 ) ); i += 2;
			minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			result = new DateTime( 1, 1, 1, hour, minute, 0, 0.0 );
		}
		break;

		// HHMMSS
		// Time with seconds: H = Hour; m = Minute; s = Seconds.
		case 402:
		{
			checkLength ( sValue, sFormat, 6 );
			hour		= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			minute	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			seconds	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			result 	= new DateTime( 1, 1, 1, hour, minute, seconds, 0.0 );
		}
			break;

		// HHMMSSZZZ
		// See 402 plus Z=Time zone.
		case 404:
		{
			checkMinMaxLength ( sValue, sFormat, 7, 9 );
			String tz;
			hour		= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			minute	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			seconds	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			tz		= new String( arrValue, i, arrValue.length - i );
			result	= new DateTime( 1, 1, 1, hour, minute, seconds, 0.0, TZConvert.Timezone(tz) );
		}
		break;

		// MMMMSS
		// Time without hours: m=minutes, s=seconds.
		case 405:
		{
			checkLength ( sValue, sFormat, 6 );
			minute	= Integer.parseInt( new String( arrValue, i, 4 ) );	i += 4;
			seconds	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			result 	= new DateTime( 1, 1, 1, minute / 60, minute % 60, seconds, 0.0 );
		}
		break;

		default:
		{
			if ( bRaiseExc ) throw new com.altova.AltovaException ("Unknown format code. Cannot convert the value '" + sValue + "' using the format code '" + sFormat + "'." );
		}
	
	}

	return result;
  }

  /* The result is the date value extracted from the coded source using the given format code.
   */
  public static DateTime toDate( String sValue, String sFormat )
  {
	  return Edifact.toDate( sValue, sFormat, true );
  }

  //Overloaded method with control parameter for the default-switch exception
  
  private static DateTime toDate( String sValue, String sFormat, boolean bRaiseExc ) {

	DateTime result = null;

	int century = 0;
	int year = 0;
	int month = 0;
	int week = 0;
	int day = 0;
	int i = 0;

	char[] arrValue = sValue.toCharArray();

	switch( Integer.parseInt(sFormat) )
	{

		// DDMMYY
		case 2:
		{
			checkLength ( sValue, sFormat, 6 );
			day     = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			month   = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			year    = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			result  = new DateTime( Y2KConvert.Year( year ), month, day );
		}
			break;

		// MMDDYY
		case 3:
		{
			checkLength ( sValue, sFormat, 6 );
			month   = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			day     = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			year    = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			result  = new DateTime( Y2KConvert.Year( year ), month, day );
		}
			break;

		// DDMMCCYY
		case 4:
		{
			checkLength ( sValue, sFormat, 8 );
			day     = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			month   = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			year    = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			result  = new DateTime( Y2KConvert.Year( century, year ), month, day );
		}
			break;

		// CCYYMMB
		// B=1:first half month, B=2:second half month.
		case 6:
		{
			checkLength ( sValue, sFormat, 7 );
			century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			year    = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			month   = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int B   = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			DateTime date = new DateTime( Y2KConvert.Year( century, year ), month, 1 );
			Duration offset = new Duration( 0, 0, 15, 0, 0, 0, 0.0, false );
			if( B == 2 ) date = Lang.datetimeAdd( date, offset );
			result = date;
		}
			break;

		// CCYYMMW
		// W=1-5 first week to fifth week in a month.
		case 7:
		{
			checkLength ( sValue, sFormat, 7 );
			century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			year    = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			month   = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			week    = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			DateTime baseDate = new DateTime( Y2KConvert.Year( century, year ), month, 1 );
			Duration days = new Duration( 0, 0, (week-1) * 7, 0, 0, 0, 0.0, false );
			result = Lang.datetimeAdd( baseDate, days );
		}
			break;

		// CCYYMMDDS
		// Shift within a calendar day: CC=century YY=year MM=month DD=day S=1-9 shift in a day.
		case 8:
		{
			checkLength ( sValue, sFormat, 9 );
			century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			year    = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			month   = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			day     = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int s   = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			result  = new DateTime( Y2KConvert.Year( century, year ), month, day );
		}
			break;

		// CCYYMMDDPP
		// Time period within a calendar day: CC=century YY=year MM=month DD=day PP=00-99 time period.
		case 9:
		{
			checkLength ( sValue, sFormat, 10 );
			century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			year    = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			month   = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			day     = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int pp  = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			result  = new DateTime( Y2KConvert.Year( century, year ), month, day );
		}
			break;


		// YYMMDD
		// Calendar date: Y = Year; M = Month; D = Day.
		case 101:
		{
			checkLength ( sValue, sFormat, 6 );
			year   = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			month  = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			day    = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			result = new DateTime( Y2KConvert.Year( year ), month, day );
		}
			break;

		// CCYYMMDD
		// Calendar date: C = Century ; Y = Year ; M = Month ; D = Day.
		case 102:
		{
			checkLength ( sValue, sFormat, 8 );
			century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			year    = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			month   = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			day     = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			result  = new DateTime( Y2KConvert.Year( century, year ), month, day );
		}
			break;

		// YYWWD
		// Calendar week day: Y = Year ; W = Week ; D = Day
		// Week number 01 is always first week of January
		// Day number 1 is always Monday.
		case 103:
		{
			checkLength ( sValue, sFormat, 5 );
			year = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			week = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			day  = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;

			DateTime date = new DateTime( Y2KConvert.Year( year ), 1, 4 );
			Duration days = new Duration( 0, 0, (week - 1) * 7 + day - 1 - date.getWeekday(), 0, 0, 0, 0.0, false );
			result = Lang.datetimeAdd( date, days );
		}
			break;

		// YYDDD
		// Calendar day: Y = Year ; D = Day
		// January the first = Day 001
		// Always start numbering the days of the year from January 1st through December 31st.
		case 105:
		{
			checkLength ( sValue, sFormat, 5 );
			year = Integer.parseInt( new String( arrValue, i, 2 ) ); i += 2;
			day	= Integer.parseInt( new String( arrValue, i, 3 ) );	i += 3;
			DateTime baseDate = new DateTime( Y2KConvert.Year( year ), 1, 1 ); // January 1st
			Duration days = new Duration( 0, 0, day-1, 0, 0, 0, 0.0, false );
			result = Lang.datetimeAdd( baseDate, days );
		}
			break;

		//YYWW
		// Week within a calendar year: Y = Year; W = Week 1st week of January = week 01.
		case 615:
		{
			checkLength ( sValue, sFormat, 4 );
			year = Integer.parseInt( new String( arrValue, i, 2 ) );  i += 2;
			week = Integer.parseInt( new String( arrValue, i, 2 ) );  i += 2;

			DateTime date = new DateTime( Y2KConvert.Year( year ), 1, 4 );
			Duration days = new Duration( 0, 0, (week - 1) * 7 - date.getWeekday(), 0, 0, 0, 0.0, false );
			result = Lang.datetimeAdd( date, days );
		}
			break;
		// CCYYWW
		// Week within a calendar year: CC = Century; Y = Year; W = Week (1st week of January = week 01).
		case 616:
		{
			checkLength ( sValue, sFormat, 6 );
			century = Integer.parseInt( new String( arrValue, i, 2 ) );  i += 2;
			year = Integer.parseInt( new String( arrValue, i, 2 ) );  i += 2;
			week = Integer.parseInt( new String( arrValue, i, 2 ) );  i += 2;

			DateTime date = new DateTime( Y2KConvert.Year( century, year ), 1, 4 );
			Duration days = new Duration( 0, 0, (week - 1) * 7 - date.getWeekday(), 0, 0, 0, 0.0, false );
			result = Lang.datetimeAdd( date, days );
		}
			break;

		default:
		{
			if ( bRaiseExc ) throw new com.altova.AltovaException ("Unknown format code. Cannot convert the value '" + sValue + "' using the format code '" + sFormat + "'." );
		}
		
	}
	return result;
  }
  
  /* The result is the datetime value extracted from the coded source using the given format code.
   */
  public static DateTime toDatetime( String sValue, String sFormat ) 
  {
	  return Edifact.toDatetime( sValue, sFormat, true );
  }

  
  //Overloaded method with control parameter for the default-switch exception
  
  private static DateTime toDatetime( String sValue, String sFormat, boolean bRaiseExc )
  {

	DateTime result = null;

	int century = 0;
	int year = 0;
	int month = 0;
	int day = 0;
	int hour = 0;
	int minute = 0;
	int seconds = 0;
	int i = 0;

	char[] arrValue = sValue.toCharArray();

	switch( Integer.parseInt(sFormat) )
	{
		// DDMMCCYYHHMM
		case 5:
		{
			checkLength ( sValue, sFormat, 12 );
			day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			month	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			year = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			result = new DateTime( Y2KConvert.Year( century, year), month, day, hour, minute, 0, 0.0 );
		}
		break;

		// CCYYMMDDTHHMM
		// Calendar date including time with minutes: C=Century; Y=Year; M=Month; D=Day; T=Time designator; H=Hour; M=Minutes.
		// The character [T] shall be used as time designator to indicate the start of the representation of the time.
		// For example: 20010912T1433.
		case 10:
		{
			checkLength ( sValue, sFormat, 13 );
			century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			year = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			month = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			char T = arrValue[ i];	i += 1;
			hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			result = new DateTime( Y2KConvert.Year( century, year), month, day, hour, minute, 0, 0.0 );
		}
		break;

		// YYMMDDHHMM
		// Calendar date including time without seconds: Y = Year; M = Month; D = Day; H = Hour; M = Minute.
		case 201:
		{
			checkLength ( sValue, sFormat, 10 );
			year = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			month = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			result = new DateTime( Y2KConvert.Year( year), month, day, hour, minute, 0, 0.0 );
		}
			break;

		// YYMMDDHHMMSS
		// Calendar date including time with seconds: Y = Year; M = Month; D = Day; H = Hour; m = Minutes = Seconds.
		case 202:
		{
			checkLength ( sValue, sFormat, 12 );
			year = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			month = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			seconds = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			result = new DateTime( Y2KConvert.Year( year), month, day, hour, minute, seconds, 0.0 );
		}
			break;

		// CCYYMMDDHHMM
		// Calendar date including time with minutes: C=Century; Y=Year; M=Month; D=Day; H=Hour; M=Minutes.
		case 203:
		{
			checkLength ( sValue, sFormat, 12 );
			century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			year = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			month	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			result = new DateTime( Y2KConvert.Year( century, year), month, day, hour, minute, 0, 0.0 );
		}
			break;

		// CCYYMMDDHHMMSS
		// Calendar date including time with seconds: C=Century;Y=Year; M=Month;D=Day;H=Hour;M=Minute;S=Second.
		case 204:
		{
			checkLength ( sValue, sFormat, 14 );
			century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			year = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			month	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			seconds = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			result = new DateTime( Y2KConvert.Year( century, year), month, day, hour, minute, seconds, 0.0 );
		}
			break;

		// CCYYMMDDHHMMZHHMM
		// Calendar date including time and time zone expressed in hours and minutes.
		// ZHHMM = time zone given as offset from Coordinated Universal Time (UTC).
		case 205:
		{
			checkLength ( sValue, sFormat, 17 );
			int offsetH = 0;
			int offsetM = 0;

			century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			year = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			month	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			char s = arrValue[ i ];	i += 1;
			offsetH = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			offsetM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int tz = ( offsetH * 60 + offsetM ) * ((s == '-') ? -1 : +1);
			result = new DateTime( Y2KConvert.Year( century, year ), month, day, hour, minute, 0, 0.0, tz );
		}
			break;

		// YYMMDDHHMMZZZ
		// See 201 + Z = Time zone.
		case 301:
		{
			checkMinMaxLength ( sValue, sFormat, 11, 13 );
			String zone;
			year	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			month	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			zone = new String( arrValue, i, arrValue.length - i );
			result = new DateTime( Y2KConvert.Year( year), month, day, hour, minute, 0, 0.0, TZConvert.Timezone(zone) );
		}
			break;

		// YYMMDDHHMMSSZZZ
		// See 202 + Z = Time zone.
		case 302:
		{
			checkMinMaxLength ( sValue, sFormat, 13, 15 );
			String zone;
			year	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			month	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			seconds = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			zone = new String( arrValue, i, arrValue.length - i );
			result = new DateTime( Y2KConvert.Year( year), month, day, hour, minute, seconds, 0.0, TZConvert.Timezone(zone) );
		}
			break;

		// CCYYMMDDHHMMZZZ
		// See 203 plus Z=Time zone.
		case 303:
		{
			checkMinMaxLength ( sValue, sFormat, 13, 15 );
			String zone;
			century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			year = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			month	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			zone = new String( arrValue, i, arrValue.length - i );
			result = new DateTime( Y2KConvert.Year( century, year), month, day, hour, minute, 0, 0.0, TZConvert.Timezone(zone) );
		}
			break;

		// CCYYMMDDHHMMSSZZZ
		// See 204 plus Z=Time zone.
		case 304:
		{
			checkMinMaxLength ( sValue, sFormat, 15, 17 );
			String zone;
			century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			year = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			month	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			seconds = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			zone = new String( arrValue, i, arrValue.length - i );
			result = new DateTime( Y2KConvert.Year( century, year), month, day, hour, minute, seconds, 0.0, TZConvert.Timezone(zone) );
		}
			break;

		default:
		{
			if ( bRaiseExc )throw new com.altova.AltovaException ("Unknown format code. Cannot convert the value '" + sValue + "' using the format code '" + sFormat + "'." );
		}
	
	}
	return result;
  }
  
  
  /* The result is the Duration value extracted from the coded source using the given format code.
   */
  public static Duration toDuration( String sValue, String sFormat )
  {
	  return Edifact.toDuration ( sValue, sFormat, true );
  }
  
  //Overloaded method with control parameter for the default-switch exception
  
  private static Duration toDuration( String sValue, String sFormat, boolean bRaiseExc )
  {

	sValue = sValue.replaceAll("-", "");
	
	Duration result = null;

	int year = 0;
	int month = 0;
	int week = 0;
	int day = 0;
	int hour = 0;
	int minute = 0;
	int seconds = 0;
	int i = 0;

	char[] arrValue = sValue.toCharArray();

	switch( Integer.parseInt(sFormat) )
	{
		// MMDD
		// Day of a month: M = Month; D = Day.
		case 106:
		{
			checkLength ( sValue, sFormat, 4 );
			month	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			day	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			result = new Duration( 0, month, day, 0, 0, 0, 0.0, false );
			//result = new DateTime( 1, month, day );
		}
			break;
			
		// MMDDHHMM
		// Month, day, hours, minutes; M = Month; D = Day; H = Hour; M = Minute.
		case 305:
		{
			checkLength ( sValue, sFormat, 8 );
			month = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			result = new Duration( 0, month, day, hour, minute, 0, 0.0, false );
		}
			break;

		// DDHHMM
		// Day, hours, minutes; D = Day; H = Hour; M = Minute.
		case 306:
		{
			checkLength ( sValue, sFormat, 6 );
			day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			result = new Duration( 0, 0, day, hour, minute, 0, 0.0, false );
		}
			break;

		// ZHHMM
		// Offset from Coordinated Universal Time (UTC) where Z is plus (+) or minus (-).
		case 406:
		{
			checkLength ( sValue, sFormat, 5 );
			char s = arrValue[ i ];	i += 1;
			hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			result = new Duration( 0, 0, 0, hour, minute, 0, 0.0, s == '-' );
		}
			break;

		// HHMMHHMM
		// Time span without seconds: H = Hour; m = Minute;.
		case 501:
		{
			checkLength ( sValue, sFormat, 8 );
			int fromH	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromM	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toH = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			DateTime from = new DateTime( 1, 1, 1, fromH, fromM, 0, 0.0 );
			DateTime to	= new DateTime( 1, 1, 1, toH, toM, 0, 0.0 );
			result = Lang.datetimeDiff( to, from );
		}
			break;

		// HHMMSS-HHMMSS
		// A period of time specified by giving the start time
		// followed by the end time (both expressed by hours
		// minutes and seconds). Data is to be transmitted as
		// consecutive characters without hyphen.
		case 502:
		{
			checkLength ( sValue, sFormat, 12 );
			int fromH	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromM	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromS	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toH = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toS = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			DateTime from = new DateTime( 1, 1, 1, fromH, fromM, fromS, 0.0 );
			DateTime to	= new DateTime( 1, 1, 1, toH, toM, toS, 0.0 );
			result = Lang.datetimeDiff( to, from );
		}
			break;

		// HHMMSSZZZ-HHMMSSZZZ
		// A period of time specified by giving the start time
		// followed by the end time (both expressed by hours
		// minutes, seconds and time zone). Data is to be
		// transmitted as consecutive characters without hyphen.
		case 503:
		{
			checkMinMaxLength ( sValue, sFormat, 14, 18 );
			String fromZ, toZ;

			int fromH	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromM	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromS	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			fromZ	= new String( arrValue, i, 3 );	i += 3;
			int toH = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toS = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			toZ = new String( arrValue, i, 3 );	i += 3;
			DateTime from = new DateTime( 1, 1, 1, fromH, fromM, fromS, 0.0, TZConvert.Timezone(fromZ) );
			DateTime to	= new DateTime( 1, 1, 1, toH, toM, toS, 0.0, TZConvert.Timezone(toZ) );
			result = Lang.datetimeDiff( to, from );
		}
			break;

		// YY-YY
		// A period of time specified by giving the start year
		// followed by the end year (both without century). Data is
		// to be transmitted as consecutive characters without
		// hyphen.
		case 701:
		{
			checkLength ( sValue, sFormat, 4 );
			int fromY	= Y2KConvert.Year( Integer.parseInt( new String( arrValue, i, 2 ) ) );	i += 2;
			int toY = Y2KConvert.Year( Integer.parseInt( new String( arrValue, i, 2 ) ) );	i += 2;
			result = Duration.getFromYearMonth( toY - fromY, 0 );
		}
			break;

		// CCYY-CCYY
		// A period of time specified by giving the start year
		// followed by the end year (both including century). Data
		// is to be transmitted as consecutive characters without hyphen.
		case 702:
		{
			checkLength ( sValue, sFormat, 8 );
			int fromC	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toC = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toY = Integer.parseInt( new String( arrValue, i, 2  ) );	i += 2;

			fromY = Y2KConvert.Year( fromC, fromY );
			toY = Y2KConvert.Year( toC, toY );

			result = Duration.getFromYearMonth( toY - fromY, 0 );
		}
			break;

		// YYS-YYS
		// A period of time specified by giving the start semester
		// of a year followed by the end semester of a year (both
		// not including century). Data is to be transmitted as
		// consecutive characters without hyphen.
		case 703:
		{
			checkLength ( sValue, sFormat, 6 );
			int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromS	= Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toS = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;

			fromY = Y2KConvert.Year( fromY );
			toY = Y2KConvert.Year( toY );
			int fromMonth = ( fromS - 1 ) * 6 + 1;
			int toMonth = ( toS - 1 ) * 6 + 1;

			result = Duration.getFromYearMonth( toY - fromY, toMonth - fromMonth );
		}
			break;

		// CCYYS-CCYYS
		// A period of time specified by giving the start semester
		// of a year followed by the end semester of a year (both
		// including century). Data is to be transmitted as
		// consecutive characters without hyphen.
		case 704:
		{
			checkLength ( sValue, sFormat, 10 );
			int fromC	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromS	= Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			int toC = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toS = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;

			fromY = Y2KConvert.Year( fromC, fromY );
			toY = Y2KConvert.Year( toC, toY );
			int fromMonth = ( fromS - 1 ) * 6 + 1;
			int toMonth = ( toS - 1 ) * 6 + 1;

			result = Duration.getFromYearMonth( toY - fromY, toMonth - fromMonth );
		}
			break;

		// YYPYYP
		// Format of period to be given without hyphen (P = period of 4 months).
		case 705:
		{
			checkLength ( sValue, sFormat, 6 );
			int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromP	= Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toP = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;

			fromY = Y2KConvert.Year( fromY );
			toY = Y2KConvert.Year( toY );
			int fromMonth = ( fromP - 1 ) * 4 + 1;
			int toMonth = ( toP - 1 ) * 4 + 1;

			result = Duration.getFromYearMonth( toY - fromY, toMonth - fromMonth );
		}
			break;

		// CCYYP-CCYYP
		// Format of period to be given without hyphen (P = period of 4 months).
		case 706:
		{
			checkLength ( sValue, sFormat, 10 );
			int fromC	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromP	= Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			int toC = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toP = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;

			fromY = Y2KConvert.Year( fromC, fromY );
			toY = Y2KConvert.Year( toC, toY );
			int fromMonth = ( fromP - 1 ) * 4 + 1;
			int toMonth = ( toP - 1 ) * 4 + 1;

			result = Duration.getFromYearMonth( toY - fromY, toMonth - fromMonth );
		}
			break;

		// YYQ-YYQ
		// A period of time specified by giving the start quarter
		// of a year followed by the end quarter of year (both not
		// including century). Data is to be transmitted as
		// consecutive characters without hyphen.
		case 707:
		{
			checkLength ( sValue, sFormat, 6 );
			int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromQ	= Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toQ = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;

			fromY = Y2KConvert.Year( fromY );
			toY = Y2KConvert.Year( toY );
			int fromMonth = ( fromQ - 1 ) * 3 + 1;
			int toMonth = ( toQ - 1 ) * 3 + 1;

			result = Duration.getFromYearMonth( toY - fromY, toMonth - fromMonth );
		}
			break;

		// CCYYQ-CCYYQ
		// A period of time specified by giving the start quarter
		// of a year followed by the end quarter of year (both
		// including century). Data is to be transmitted as
		// consecutive characters without hyphen.
		case 708:
		{
			checkLength ( sValue, sFormat, 10 );
			int fromC	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromQ	= Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			int toC = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toQ = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;

			fromY = Y2KConvert.Year( fromC, fromY );
			toY = Y2KConvert.Year( toC, toY );
			int fromMonth = ( fromQ - 1 ) * 3 + 1;
			int toMonth = ( toQ - 1 ) * 3 + 1;

			result = Duration.getFromYearMonth( toY - fromY, toMonth - fromMonth );
		}
			break;

			// YYMM-YYMM
			// A period of time specified by giving the start month of
			// a year followed by the end month of a year (both not
			// including century). Data is to be transmitted as
			// consecutive characters without hyphen.
		case 709:
		{
			checkLength ( sValue, sFormat, 8 );
			int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromM	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;

			fromY = Y2KConvert.Year( fromY );
			toY = Y2KConvert.Year( toY );

			result = Duration.getFromYearMonth( toY - fromY, toM - fromM );
		}
			break;

		// CCYYMM-CCYYMM
		// A period of time specified by giving the start month of
		// a year followed by the end month of a year (both
		// including century). Data is to be transmitted as
		// consecutive characters without hyphen.
		case 710:
		{
			checkLength ( sValue, sFormat, 12 );
			int fromC	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromM	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toC = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;

			fromY = Y2KConvert.Year( fromC, fromY );
			toY = Y2KConvert.Year( toC, toY );

			result = Duration.getFromYearMonth( toY - fromY, toM - fromM );
		}
			break;

		// CCYYMMDD-CCYYMMDD
		// Format of period to be given in actual message without
		// hyphen.
		// Note:
		// 1. This code value will be removed effective with
		// directory D.03B.
		case 711:
		{
			checkLength ( sValue, sFormat, 16 );
			int fromC	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromM	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromD	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toC = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toD = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			DateTime from = new DateTime( Y2KConvert.Year( fromC, fromY ), fromM, fromD, 0, 0, 0, 0.0 );
			DateTime to	= new DateTime( Y2KConvert.Year( toC, toY ), toM, toD, 0, 0, 0, 0.0 );
			result = Lang.datetimeDiff( to, from );
		}
			break;

		// YYMMDDHHMM-YYMMDDHHMM
		// A period of time specified by giving the start time
		// followed by the end time (format year, month, day, hour
		// and minute). Data is to be transmitted as consecutive
		// characters without hyphen.
		case 713:
		{
			checkLength ( sValue, sFormat, 20 );
			int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromM	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromD	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromTH = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromTM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toD = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toTH = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toTM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			DateTime from = new DateTime( Y2KConvert.Year( fromY ), fromM, fromD, fromTH, fromTM, 0, 0.0 );
			DateTime to	= new DateTime( Y2KConvert.Year( toY ), toM, toD, toTH, toTM, 0, 0.0 );
			result = Lang.datetimeDiff( to, from );
		}
			break;

		// YYWW-YYWW
		// A period of time specified by giving the start week of a
		// year followed by the end week of year (both not
		// including century). Data is to be transmitted as
		// consecutive characters without hyphen.
		case 715:
		{
			checkLength ( sValue, sFormat, 8 );
			int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromW	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toW = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			DateTime from = new DateTime( Y2KConvert.Year( fromY ), 1, 1, 0, 0, 0, 0.0 );
			DateTime to	= new DateTime( Y2KConvert.Year( toY ), 1, 1, 0, 0, 0, 0.0 );
			from   = Lang.datetimeAdd( from, new Duration(0, 0, 7 * fromW, 0, 0, 0, 0.0, false) );
			to     = Lang.datetimeAdd( to,   new Duration(0, 0, 7 * toW,   0, 0, 0, 0.0, false) );
			result = Lang.datetimeDiff( to, from );
		}
			break;

		// CCYYWW-CCYYWW
		// A period of time specified by giving the start week of a
		// year followed by the end week of year (both including
		// century). Data is to be transmitted as consecutive
		// characters without hyphen.
		case 716:
		{
			checkLength ( sValue, sFormat, 12 );
			int fromC	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromW	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toC = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toW = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			DateTime from = new DateTime( Y2KConvert.Year( fromC, fromY ), 1, 1, 0, 0, 0, 0.0 );
			DateTime to	= new DateTime( Y2KConvert.Year( toC, toY ), 1, 1, 0, 0, 0, 0.0 );
			from   = Lang.datetimeAdd( from, new Duration(0, 0, 7 * fromW, 0, 0, 0, 0.0, false) );
			to     = Lang.datetimeAdd( to,   new Duration(0, 0, 7 * toW,   0, 0, 0, 0.0, false) );
			result = Lang.datetimeDiff( to, from );
		}
			break;

		// YYMMDD-YYMMDD
		// A period of time specified by giving the start date
		// followed by the end date (both not including century).
		// Data is to be transmitted as consecutive characters
		// without hyphen.
		case 717:
		{
			checkLength ( sValue, sFormat, 12 );
			int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromM	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromD	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toD = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			DateTime from = new DateTime( Y2KConvert.Year( fromY ), fromM, fromD, 0, 0, 0, 0.0 );
			DateTime to	= new DateTime( Y2KConvert.Year( toY ), toM, toD, 0, 0, 0, 0.0 );
			result = Lang.datetimeDiff( to, from );
		}
			break;

		// CCYYMMDD-CCYYMMDD
		// A period of time specified by giving the start date
		// followed by the end date (both including century). Data
		// is to be transmitted as consecutive characters without
		// hyphen.
		case 718:
		{
			checkLength ( sValue, sFormat, 16 );
			int fromC	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromM	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromD	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toC = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toD = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			DateTime from	= new DateTime( Y2KConvert.Year( fromC, fromY ), fromM, fromD, 0, 0, 0, 0.0 );
			DateTime to	= new DateTime( Y2KConvert.Year( toC, toY ), toM, toD, 0, 0, 0, 0.0 );
			result = Lang.datetimeDiff( to, from );
		}
			break;

		// CCYYMMDDHHMM-CCYYMMDDHHMM
		// A period of time which includes the century, year,
		// month, day, hour and minute. Format of period to be
		// given in actual message without hyphen.
		case 719:
		{
			checkLength ( sValue, sFormat, 24 );
			int fromC	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromM	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromD	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromTH = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromTM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toC = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toD = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toTH = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toTM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			DateTime from = new DateTime( Y2KConvert.Year( fromC, fromY ), fromM, fromD, fromTH, fromTM, 0, 0.0 );
			DateTime to	= new DateTime( Y2KConvert.Year( toC, toY ), toM, toD, toTH, toTM, 0, 0.0 );
			result = Lang.datetimeDiff( to, from );
		}
			break;

		// DHHMM-DHHMM
		// Format of period to be given without hyphen (D=day of
		// the week, 1=Monday; 2=Tuesday; ... 7=Sunday).
		case 720:
		{
			checkLength ( sValue, sFormat, 10 );
			int fromDOW = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			int fromTH = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int fromTM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toDOW	= Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			int toTH = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			int toTM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;

			fromDOW = ( fromDOW % 7 ) + 1;
			toDOW	= ( toDOW % 7 ) + 1;

			DateTime from = new DateTime(1, 1, 1, fromTH, fromTM, 0, 0.0 );
			Duration oneday = new Duration( 0, 0, 1, 0, 0, 0, 0.0, false );
			while( Lang.weekday( from ) != fromDOW )
				from = Lang.datetimeAdd( from, oneday );

			DateTime to = new DateTime( from.getYear(), from.getMonth(), from.getDay(), toTH, toTM, 0, 0.0 );
			while( Lang.weekday( to ) != toDOW )
				to = Lang.datetimeAdd( to, oneday );

			result = Lang.datetimeDiff( to, from );
		}
			break;

		// Year
		// To indicate a quantity of years.
		case 801:
		{
			year = Integer.parseInt( sValue );
			result = Duration.getFromYearMonth( year, 0 );
		}
			break;

		// Month
		// To indicate a quantity of months.
		case 802:
		{
			month = Integer.parseInt( sValue );
			result = Duration.getFromYearMonth( 0, month );
		}
			break;

		// Week
		// To indicate a quantity of weeks.
		case 803:
		{
			week = Integer.parseInt( sValue );
			result = Duration.getFromDayTime( week * 7, 0, 0, 0, 0.0 );
		}
			break;

		// Day
		// To indicate a quantity of days.
		case 804:
		{
			day = Integer.parseInt( sValue );
			result = Duration.getFromDayTime( day, 0, 0, 0, 0.0 );
		}
			break;

		// Hour
		// To indicate a quantity of hours.
		case 805:
		{
			hour = Integer.parseInt( sValue );
			result = Duration.getFromDayTime( 0, hour, 0, 0, 0.0 );
		}
			break;

		// Minute
		// To indicate a quantity of minutes.
		case 806:
		{
			minute = Integer.parseInt( sValue );
			result = Duration.getFromDayTime( 0, 0, minute, 0, 0.0 );
		}
			break;

		// Second
		// To indicate a quantity of seconds.
		case 807:
		{
			seconds = Integer.parseInt( sValue );
			result = Duration.getFromDayTime( 0, 0, 0, seconds, 0.0 );
		}
			break;

		// Semester
		// To indicate a quantity of semesters (six months).
		case 808:
		{
			int semester = Integer.parseInt( sValue );
			result = Duration.getFromYearMonth( 0, semester * 6 );
		}
			break;

		// Four months period
		// To indicate a quantity of four months periods.
		case 809:
		{
			int fourMonth = Integer.parseInt( sValue );
			result = Duration.getFromYearMonth( 0, fourMonth * 4 );
		}
			break;

		// Trimester
		// To indicate a quantity of trimesters (three months).
		case 810:
		{
			int trimester = Integer.parseInt( sValue );
			result = Duration.getFromYearMonth( 0, trimester * 3 );
		}
			break;

		// Half month
		// To indicate a quantity of half months.
		case 811:
		{
			int halfMonth = Integer.parseInt( sValue );
			Duration dur = Duration.getFromDayTime( (halfMonth % 2) * 15, 0, 0, 0, 0.0 );
			Duration durYM = Duration.getFromYearMonth( 0, halfMonth / 2 );
			dur.setYearMonthValue( durYM.getYearMonthValue() );
			result = dur;
		}
			break;

		// Ten days
		// To indicate a quantity of ten days periods.
		case 812:
		{
			int tenDays = Integer.parseInt( sValue );
			result = Duration.getFromDayTime( tenDays * 10, 0, 0, 0, 0.0 );
		}
			break;

		default:
		{
			if ( bRaiseExc ) throw new com.altova.AltovaException ("Unknown format code. Cannot convert the value '" + sValue + "' using the format code '" + sFormat + "'." );
		}
	
	}

	return result;
  }
  
  private static void checkLength( String sValue, String sFormat, int nLength ) 
  {
		  if ( sValue.length() != nLength)
			  throw new com.altova.AltovaException ("Cannot convert the value '" + sValue + "' using the format code '" + sFormat + "'. Expected length '" + nLength + "'." );
  }
  

  private static void checkMinMaxLength( String sValue, String sFormat, int nMinLength, int nMaxLength ) 
  {
	  if ( ( sValue.length() < nMinLength ) || ( sValue.length() > nMaxLength ) )
		  throw new com.altova.AltovaException ("Cannot convert the value '" + sValue + "' using the format code '" + sFormat + "'. Expected length between '" + nMinLength + "' and '" + nMaxLength + "'." );
  }

	static class Y2KConvert
	{
		public static final int Year( int nYear )					{ return nYear > 50 ? 1900 + nYear : 2000 + nYear; }
		public static final int Year( int nCentury, int nYear )		{ return (nCentury * 100) + nYear; }
	};

	static class TZConvert
	{
		static class TimeZoneData
		{
			public String	sName;
			public float	dOffset;

			public TimeZoneData( String name, float offset )
			{
				sName = name;
				dOffset = offset;
			}
		}

		static TimeZoneData[] arrAbb =
			{
				new TimeZoneData("NST",+12.0f),	/* Pacific/Auckland */
				new TimeZoneData("SST",+11.0f),	/* Pacific/Guadalcanal */
				new TimeZoneData("AET",+10.0f),	/* Australia/Sydney */
				new TimeZoneData("ACT", +9.5f),	/* Australia/Darwin */
				new TimeZoneData("JST", +9.0f),	/* Asia/Tokyo */
				new TimeZoneData("CTT", +8.0f),	/* Asia/Shanghai */
				new TimeZoneData("VST", +7.0f),	/* Asia/Saigon */
				new TimeZoneData("BST", +6.0f),	/* Asia/Dacca */
				new TimeZoneData("IST", +5.5f),	/* Asia/Calcutta */
				new TimeZoneData("PLT", +5.0f),	/* Asia/Karachi */
				new TimeZoneData("NET", +4.0f),	/* Asia/Yerevan */
				new TimeZoneData("MET", +3.5f),	/* Asia/Tehran */
				new TimeZoneData("EAT", +3.0f),	/* Africa/Addis_Ababa */
				new TimeZoneData("EET", +2.0f),	/* Europe/Istanbul */
				new TimeZoneData("ART", +2.0f),	/* Africa/Cairo */
				new TimeZoneData("CAT", +2.0f),	/* Africa/Harare */
				new TimeZoneData("ECT", +1.0f),	/* Europe/Paris */
				new TimeZoneData("CET", +1.0f),	/* Europe/Paris */
				new TimeZoneData("GMT",  0.0f),	/* GMT */
				new TimeZoneData("UT",   0.0f),	/* GMT */
				new TimeZoneData("UTC",  0.0f),	/* GMT */
				new TimeZoneData("BET", -3.0f),	/* America/Sao_Paulo */
				new TimeZoneData("AGT", -3.0f),	/* America/Buenos_Aires */
				new TimeZoneData("CNT", -3.5f),	/* America/St_Johns */
				new TimeZoneData("PRT", -5.0f),	/* America/Puerto_Rico */
				new TimeZoneData("EST", -5.0f),	/* America/New_York */
				new TimeZoneData("IET", -5.0f),	/* America/Indianapolis */
				new TimeZoneData("CST", -6.0f),	/* America/Chicago */
				new TimeZoneData("MST", -7.0f),	/* America/Denver */
				new TimeZoneData("PNT", -7.0f),	/* America/Phoenix */
				new TimeZoneData("PST", -8.0f),	/* America/Los_Angeles */
				new TimeZoneData("MDT", -8.0f),	/* America/Boise */			/* Mountain Standard Time */
				new TimeZoneData("AST", -9.0f),	/* America/Anchorage */
				new TimeZoneData("PDT", -9.0f),	/* America/Dawson */		/* Pacific Standard Time */
				new TimeZoneData("HST",-10.0f),	/* Pacific/Honolulu */
				new TimeZoneData("TKT",-10.0f),	/* Pacific/Fakaofo */		/* Tokelau Time */
				new TimeZoneData("CKT",-10.0f),	/* Pacific/Rarotonga */		/* Cook Is. Time */
				new TimeZoneData("MIT",-11.0f),	/* Pacific/Apia */
				new TimeZoneData("WST",-11.0f),	/* Pacific/Apia */
				new TimeZoneData("SST",-11.0f),	/* Pacific/Midway */		/* Samoa Standard Time */
				new TimeZoneData("NUT",-11.0f),	/* Pacific/Niue */			/* Niue Time */
			};

		public static TimeZoneData[] arrMil = new TimeZoneData[]
			{
				new TimeZoneData("Z", 0.0f), // Zulu Time ( UTC )
				new TimeZoneData("A", +1.0f), new TimeZoneData("B", +2.0f), new TimeZoneData("C", +3.0f), new TimeZoneData("D", +4.0f), new TimeZoneData("E", +5.0f), new TimeZoneData("F", +6.0f), new TimeZoneData("G", +7.0f), new TimeZoneData("H", +8.0f), new TimeZoneData("I", +9.0f), new TimeZoneData("K", +10.0f), new TimeZoneData("L", +11.0f), new TimeZoneData("M", +12.0f),
				new TimeZoneData("N", -1.0f), new TimeZoneData("O", -2.0f), new TimeZoneData("P", -3.0f), new TimeZoneData("Q", -4.0f), new TimeZoneData("R", -5.0f), new TimeZoneData("S", -6.0f), new TimeZoneData("T", -7.0f), new TimeZoneData("U", -8.0f), new TimeZoneData("V", -9.0f), new TimeZoneData("W", -10.0f), new TimeZoneData("X", -11.0f), new TimeZoneData("Y", -12.0f),
			};

		public static int Timezone( String sTimezone )
		{
			// Input Parameter:
			// coded tz value like "GMT", "Z" or "+10"
			// Return Value:
			// the corresponding timezone offset in MINUTES!
			// when the tz couldn't be found the return value is 0.
			// Possible formats for Timezone resolution:
			// - Hour offset from GMT (+/-HH)
			// - Three letter timezone code
			// - One letter millitary code (Z=UTC)

			// Pass 1:
			// check the length of the input string.
			// For single letter lookup the timezone offset from the tzMil array.
			if( sTimezone.length() == 1 )
			{
				for( int i=0; i < arrMil.length; ++i )
					if( sTimezone.compareToIgnoreCase( arrMil[i].sName ) == 0 )
						return (int)( 60 * arrMil[i].dOffset );
			}
			else
			{
				// Pass 2:
				// lookup the timezone offset from tzAbb array
				// all standard timezones and the offsets are recorded
				for( int i=0; i < arrAbb.length; ++i )
					if( sTimezone.compareToIgnoreCase( arrAbb[i].sName ) == 0 )
						return (int)( 60 * arrAbb[i].dOffset );

				try
				{
					int offset = Integer.parseInt(sTimezone);
					return offset * 60;
				}
				catch( NumberFormatException ex )
				{
					System.err.println("ERROR: cannot convert the given value (" + sTimezone + ") to a timezone offset");
				}
			}
			return 0;
		}
	}
}
